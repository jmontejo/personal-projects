%!PS-Adobe-2.0
%%Creator: dvips(k) 5.992 Copyright 2012 Radical Eye Software
%%Title: ttbb_FSR.dvi
%%CreationDate: Sun Mar 22 17:01:12 2015
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 567 341
%%DocumentFonts: HFBR17 HFBRMI10 HFBRSY10 HFBR10
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips ttbb_FSR.dvi
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2015.03.22:1701
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 647 2012-02-12 15:03:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.12, 2012/02/12
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionaray
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
/Rand { rand 4294967295 div } def		% a real random number
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def

    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
  pop pop 
} def
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput { 
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
} def
%
/BeginOL { 
  dup (all) eq exch TheOL eq or 
    { IfVisible not { Visible /IfVisible true def } if } 
    { IfVisible { Invisible /IfVisible false def } if } ifelse 
} def
%
/InitOL { 
  /OLUnit [ 3000 3000 matrix defaultmatrix dtransform ] cvx def
  /Visible { CP OLUnit idtransform T moveto } def 
  /Invisible { CP OLUnit neg exch neg exch idtransform T moveto } def 
  /BOL { BeginOL } def
  /IfVisible true def 
} def
%
%%%%%%%%%%%%%%%%% tools %%%%%%%%%%%%%%%%%%%%%%%%%
%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort {
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a
end
} def
%
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 594 2011-10-31 18:13:18Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 622 2012-01-01 15:36:14Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.02, 2012/01/01
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 130 2009-08-27 08:55:03Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
TeXDict begin @defspecial

 /pi 3.141592 def /ed{exch def}def /gs{gsave dup scale}def /gsw{ gs
/width ed width setlinewidth }def /p1{/y1 ed /x1 ed}def /p2{/y2 ed
/x2 ed}def /p3{/y3 ed /x3 ed}def /p4{/y4 ed /x4 ed}def /garrow{/arrowpos
ed /arrowspec ed}def /setabs{ dup load abs def }def /normalizearc {
translate exch dup rotate sub 3 2 roll { neg 1 -1 scale } if dup abs
360 ge { pop 360 } { dup dup 0 lt { 360 sub } if 360 div truncate 360
mul sub dup 0.1 lt { pop 360 } if }ifelse } def /normalizeline { 3
index 3 index translate 2 index sub exch 3 index sub 2 copy atan rotate
dup mul exch dup mul add sqrt 3 1 roll pop pop } def /abox{ newpath
x1 y1 moveto x1 y2 lineto x2 y2 lineto x2 y1 lineto closepath }def
/atriangle{ newpath x1 y1 moveto x2 y2 lineto x3 y3 lineto closepath
}def /abezier{ newpath x1 y1 moveto x2 y2 x3 y3 x4 y4 curveto }def
/distance{ dup 3 index sub dup mul 2 index 5 index sub dup mul add
sqrt } def

 /arrowVTriangle { /arrowinset ed /arrowlength ed /arrowwidth ed /arrowstroke
ed newpath 0 arrowlength -0.5 mul moveto arrowwidth arrowlength rlineto
arrowwidth -1 mul arrowlength arrowinset mul -1 mul rlineto arrowwidth
-1 mul arrowlength arrowinset mul rlineto closepath arrowstroke 0 ne
{ gsave arrowstroke setlinewidth stroke grestore } if fill } def /arrow1
{ gsave rotate exec grestore } def

 /fixdash{ 2 copy gt 1 index 0 ne and { 2 copy 2 mul div 0.5 sub round
dup 0 le { pop 0 } if 2 mul 1 add exch pop div dup 2 array astore 0
setdash } { pop pop [] 0 setdash } ifelse } def

 /dashline{ gsave distance dsize fixdash newpath moveto lineto stroke
grestore } def

 /dasharc{ gsave 3 copy sub abs pi mul 180 div mul 3 index angdsize
mul fixdash newpath arc stroke grestore } def

 /doublegluon{ gsw /linesep ed /num ed /ampi ed normalizeline /dr ed
linesep 0 eq { 0 0 dr 0 ampi num gluon1 } { 0 linesep 2 div dup dr
exch ampi num gluon1 0 linesep -2 div dup dr exch ampi num gluon1 }
ifelse grestore } def

 /gluon1{ gsave /num ed /ampi ed normalizeline /dr ed /num num 0.5
sub round def /inc dr num 2 mul 2 add div def /amp8 ampi 0.9 mul def
amp8 0 lt {/amp8 amp8 neg def} if /x1 inc 2 mul def newpath 0 0 moveto
inc 0.1 mul ampi 0.5 mul inc 0.5 mul ampi inc 1.4 mul ampi curveto
x1 amp8 add dup ampi exch ampi neg dup x1 exch curveto 2 1 num { pop
x1 amp8 sub dup ampi neg exch ampi dup x1 inc add exch curveto /x1
x1 inc dup add add def x1 amp8 add dup ampi exch ampi neg dup x1 exch
curveto } for x1 amp8 sub dup ampi neg exch ampi dup x1 inc 0.6 mul
add exch curveto x1 inc 1.5 mul add ampi dr inc 0.1 mul sub ampi 0.5
mul dr 0 curveto stroke grestore } def

 /doublephoton{ gsw /linesep ed /num ed /ampi ed normalizeline /dr
ed linesep 0 eq { 0 0 dr 0 ampi num photon1 } { 0 linesep 2 div dup
dr exch ampi num photon1 0 linesep -2 div dup dr exch ampi num photon1
} ifelse grestore } def

 /photon1{ gsave /num1 ed /ampi1 ed normalizeline /dr ed /num1 num1
2 mul 0.5 sub round def /x2 dr num1 div def /sign 1 def 1 1 num1 {
pop newpath 0 0 moveto 4 3 div x2 mul pi div dup neg x2 add 4 3 div
ampi1 sign mul mul dup 3 1 roll x2 0 curveto stroke /sign sign neg
def x2 0 translate } for grestore } def

 /zigzag{ gsw /num ed /ampi ed normalizeline /dr ed /num num 2 mul
0.5 sub round def /x2 dr num div def /sign 1 def 1 1 num { pop newpath
0 0 moveto x2 2 div ampi sign mul lineto x2 0 lineto stroke /sign sign
neg def x2 0 translate } for grestore } def

 /doublephotonarc{ gsw normalizearc /darc ed /radius ed /linesep ed
/num ed /ampli ed /num num 2 mul round def /darc1 darc num div def
/cp darc1 cos def /sp darc1 sin def darc1 2 div dup /cp2 exch cos def
/sp2 exch sin def linesep 0 eq { radius photonarc1 } { linesep 2 div
radius add photonarc1 linesep -2 div radius add photonarc1 } ifelse
grestore } def

 /photonarc1{ gsave /radius1 ed /ampli1 ampli def newpath 1 1 num {
pop radius1 0 moveto /beta radius1 darc1 mul 180 ampli1 mul div def
/tt sp cp beta mul sub cp sp beta mul add div def /amp1 radius1 ampli1
add 8 mul beta cp2 mul sp2 sub mul beta 4 cp add mul tt cp mul 3 mul
sp 4 mul sub add radius1 mul sub beta tt sub 3 mul div def radius1
ampli1 add 8 mul cp2 mul 1 cp add radius1 mul sub 3 div amp1 sub dup
radius1 sub beta mul amp1 dup radius1 cp mul sub tt mul radius1 sp
mul add radius1 cp mul radius1 sp mul curveto /ampli1 ampli1 neg def
darc1 rotate } for stroke grestore } def

 /doublegluearc{ gsw normalizearc /darc ed /radius ed /linesep ed /num
ed /ampi ed /num num 0.5 sub round def linesep 0 eq { radius gluearc1
} { linesep 2 div radius add gluearc1 linesep -2 div radius add gluearc1
} ifelse grestore } def

 /gluearc1{ gsave /radius1 ed /dr radius1 darc mul pi mul 180 div def
/const darc dr div def darc 360 lt { /inc dr num 2 mul 2 add div def
} { /inc dr num 2 mul div def } ifelse /amp8 ampi 0.9 mul def /amp1
radius1 ampi add def /amp2 radius1 ampi sub def /amp3 radius1 ampi
2 div add def /amp4 amp1 inc amp8 add const mul cos div def /amp5 amp2
amp8 const mul cos div def /amp6 amp1 inc 0.6 mul amp8 add const mul
cos div def /amp7 amp1 inc 0.9 mul const mul cos div def amp8 0 lt
{/amp8 amp8 neg def} if newpath darc 360 lt { /x1 inc 2 mul def radius1
0 moveto inc 0.1 mul const mul dup cos amp3 mul exch sin amp3 mul inc
0.5 mul const mul dup cos amp7 mul exch sin amp7 mul inc 1.4 mul const
mul dup cos amp1 mul exch sin amp1 mul curveto x1 amp8 add const mul
dup cos amp6 mul exch sin amp6 mul x1 amp8 add const mul dup cos amp5
mul exch sin amp5 mul x1 const mul dup cos amp2 mul exch sin amp2 mul
curveto 2 1 num } { /x1 0 def amp2 0 moveto 1 1 num } ifelse { pop
x1 amp8 sub const mul dup cos amp5 mul exch sin amp5 mul x1 amp8 sub
const mul dup cos amp4 mul exch sin amp4 mul x1 inc add const mul dup
cos amp1 mul exch sin amp1 mul curveto /x1 x1 inc dup add add def x1
amp8 add const mul dup cos amp4 mul exch sin amp4 mul x1 amp8 add const
mul dup cos amp5 mul exch sin amp5 mul x1 const mul dup cos amp2 mul
exch sin amp2 mul curveto } for darc 360 lt { x1 amp8 sub const mul
dup cos amp5 mul exch sin amp5 mul x1 amp8 sub const mul dup cos amp6
mul exch sin amp6 mul x1 inc 0.6 mul add const mul dup cos amp1 mul
exch sin amp1 mul curveto x1 inc 1.5 mul add const mul dup cos amp7
mul exch sin amp7 mul dr inc 0.1 mul sub const mul dup cos amp3 mul
exch sin amp3 mul dr const mul dup cos radius1 mul exch sin radius1
mul curveto } if stroke grestore } def

 /dasharrowdoubleline{ gsw normalizeline /dr ed /dsize ed /linesep
ed /flip ed garrow /linesep setabs /linewidth width def /y11 linesep
0.5 mul def /y22 linesep -0.5 mul def 0 y11 dr arrowpos mul y11 dashline
linesep 0 ne { 0 y22 dr arrowpos mul y22 dashline } if dr arrowpos
mul 0 translate /arrowspec load flip { -90 }{ 90 } ifelse arrow1 0
y11 dr 1 arrowpos sub mul y11 dashline linesep 0 ne { 0 y22 dr 1 arrowpos
sub mul y22 dashline } if grestore } def

 /arc2{ gsw normalizearc /darc ed /radius ed /dsize ed /linesep ed
/angdsize dsize radius div def /flip ed garrow /arcmid darc arrowpos
mul def dsize 0 eq { linesep 0 eq { 0 0 radius 0 darc dasharc } { 0
0 radius linesep 2 div add 0 darc dasharc 0 0 radius linesep -2 div
add 0 darc dasharc } ifelse } { linesep 0 eq { 0 0 radius 0 arcmid
dasharc 0 0 radius arcmid darc dasharc } { 0 0 radius linesep 2 div
add 0 arcmid dasharc 0 0 radius linesep -2 div add 0 arcmid dasharc
0 0 radius linesep 2 div add arcmid darc dasharc 0 0 radius linesep
-2 div add arcmid darc dasharc } ifelse } ifelse arcmid rotate radius
0 translate /arrowspec load flip { 0 } { 180 } ifelse arrow1 grestore
} def

 /vertex{ gs /dotsize ed translate newpath 0 0 dotsize 0 360 arc fill
stroke grestore } def

 /bcirc{ gsw /radius ed translate gsave 1 setgray newpath 0 0 radius
0 360 arc fill grestore newpath 0 0 radius 0 360 arc stroke grestore
} def

 /gcirc{ gsw /gcolor ed /radius ed translate 1 setgray newpath 0 0
radius 0 360 arc fill gcolor setgray newpath 0 0 radius 0 360 arc fill
0 setgray newpath 0 0 radius 0 360 arc stroke grestore } def

 /ccirc1{ gsw /radius ed translate newpath 0 0 radius 0 360 arc fill
grestore } def

 /ccirc2{ gsw /radius ed translate newpath 0 0 radius 0 360 arc stroke
grestore } def

 /box{ gsw p2 p1 abox stroke grestore } def

 /bbox{ gsw p2 p1 gsave 1 setgray abox fill grestore abox stroke grestore
} def

 /gbox{ gsw /gcolor ed p2 p1 1 setgray abox fill gcolor setgray abox
fill 0 setgray abox stroke grestore } def

 /cbox1{ gsw p2 p1 abox fill grestore } def

 /cbox2{ gsw p2 p1 abox stroke grestore } def

 /triangle{ gsw p3 p2 p1 atriangle stroke grestore } def

 /btriangle{ gsw p3 p2 p1 gsave 1 setgray atriangle fill grestore atriangle
stroke grestore } def

 /gtriangle{ gsw /gcolor ed p3 p2 p1 1 setgray atriangle fill gcolor
setgray atriangle fill 0 setgray atriangle stroke grestore } def

 /ctriangle1{ gsw p3 p2 p1 atriangle fill grestore } def

 /ctriangle2{ gsw p3 p2 p1 atriangle stroke grestore } def

 /btext{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def gsave 1 setgray abox fill grestore
abox stroke hsize 2 div neg fsize 3 div neg moveto thetext show grestore
} def

 /b2text{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def gsave 1 setgray abox fill grestore abox stroke hsize1 2
div neg fsize 6 div moveto text1 show hsize2 2 div neg fsize 5 mul
6 div neg moveto text2 show grestore } def

 /gtext{ gsw /fsize ed /thetext ed /graysc ed translate /hsize thetext
stringwidth pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul
3 div neg def /x2 x1 neg def /y2 y1 neg def graysc setgray abox fill
0 setgray abox stroke hsize 2 div neg fsize 3 div neg moveto thetext
show grestore } def

 /ctext1{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def abox fill grestore } def

 /ctext2{ gsw /fsize ed /thetext ed translate /hsize thetext stringwidth
pop def /x1 hsize fsize add 2 div neg def /y1 fsize 2 mul 3 div neg
def /x2 x1 neg def /y2 y1 neg def abox stroke hsize 2 div neg fsize
3 div neg moveto thetext show grestore } def

 /g2text{ gsw /fsize ed /text2 ed /text1 ed /graysc ed translate /hsize1
text1 stringwidth pop def /hsize2 text2 stringwidth pop def hsize1
hsize2 lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize
fsize add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def
/y2 y1 neg def graysc setgray abox fill 0 setgray abox stroke hsize1
2 div neg fsize 6 div moveto text1 show hsize2 2 div neg fsize 5 mul
6 div neg moveto text2 show grestore } def

 /c2text1{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def abox fill grestore } def

 /c2text2{ gsw /fsize ed /text2 ed /text1 ed translate /hsize1 text1
stringwidth pop def /hsize2 text2 stringwidth pop def hsize1 hsize2
lt { /hsize hsize2 def } { /hsize hsize1 def } ifelse /x1 hsize fsize
add 2 div neg def /y1 fsize neg 7 mul 6 div def /x2 x1 neg def /y2
y1 neg def abox stroke hsize1 2 div neg fsize 6 div moveto text1 show
hsize2 2 div neg fsize 5 mul 6 div neg moveto text2 show grestore }
def

 /ptext{ gs /text ed /fsize ed /mode ed 3 1 roll translate rotate mode
3 lt { 0 fsize neg translate } { mode 6 lt { /mode mode 3 sub def 0
fsize 2 div neg translate } { /mode mode 6 sub def } ifelse } ifelse
/fsize text stringwidth pop def mode 1 eq { fsize 2 div neg 0 translate
} { mode 2 eq { fsize neg 0 translate } if } ifelse 0 0 moveto text
show grestore } def

 /goval{ gsw /gcolor ed /x1 ed /x2 ed /radius ed translate x1 rotate
x2 radius div 1.0 scale 1 setgray newpath 0 0 radius 0 360 arc fill
gcolor setgray newpath 0 0 radius 0 360 arc fill 0 setgray newpath
0 0 radius 0 360 arc stroke grestore } def

 /coval1{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc fill grestore } def

 /coval2{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc stroke grestore } def

 /oval{ gsw /x1 ed /x2 ed /radius ed translate x1 rotate x2 radius
div 1.0 scale newpath 0 0 radius 0 360 arc stroke grestore } def

 /docurve{ x1 2 mul x2 add 3 div y1 y0 sub x1 x0 sub div x2 x0 sub
mul y2 y0 sub x2 x0 sub div x1 x0 sub mul add y1 add y0 2 mul add 3
div x1 x2 2 mul add 3 div y2 y3 sub x2 x3 sub div x1 x3 sub mul y1
y3 sub x1 x3 sub div x2 x3 sub mul add y2 add y3 2 mul add 3 div x2
y2 curveto } def

 /makecurve{ gsw /points ed /ss points length 2 idiv 2 mul def newpath
ss 4 gt { /x1 points 0 get def /y1 points 1 get def /x2 points 2 get
def /y2 points 3 get def /x3 points 4 get def /y3 points 5 get def
/x0 x1 2 mul x2 sub def /y0 y3 y2 sub x3 x2 sub div y2 y1 sub x2 x1
sub div sub 2 mul x2 x1 sub dup mul x3 x1 sub div mul y1 2 mul add
y2 sub def x1 y1 moveto docurve 0 2 ss 8 sub { /ii ed /x0 points ii
get def /y0 points ii 1 add get def /x1 points ii 2 add get def /y1
points ii 3 add get def /x2 points ii 4 add get def /y2 points ii 5
add get def /x3 points ii 6 add get def /y3 points ii 7 add get def
docurve } for /x0 points ss 6 sub get def /y0 points ss 5 sub get def
/x1 points ss 4 sub get def /y1 points ss 3 sub get def /x2 points
ss 2 sub get def /y2 points ss 1 sub get def /x3 x2 2 mul x1 sub def
/y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub 2 mul x2 x1
sub dup mul x2 x0 sub div mul y2 2 mul add y1 sub def docurve } { ss
4 eq { points 0 get points 1 get moveto points 2 get points 3 get lineto
} if } ifelse stroke grestore } def

 /makedashcurve{ gsw /dsize ed /points ed /ss points length 2 idiv
2 mul def newpath ss 4 gt { /x1 points 0 get def /y1 points 1 get def
/x2 points 2 get def /y2 points 3 get def /x3 points 4 get def /y3
points 5 get def /x0 x1 2 mul x2 sub def /y0 y3 y2 sub x3 x2 sub div
y2 y1 sub x2 x1 sub div sub 2 mul x2 x1 sub dup mul x3 x1 sub div mul
y1 2 mul add y2 sub def x1 y1 moveto docurve 0 2 ss 8 sub { /ii ed
/x0 points ii get def /y0 points ii 1 add get def /x1 points ii 2 add
get def /y1 points ii 3 add get def /x2 points ii 4 add get def /y2
points ii 5 add get def /x3 points ii 6 add get def /y3 points ii 7
add get def docurve } for /x0 points ss 6 sub get def /y0 points ss
5 sub get def /x1 points ss 4 sub get def /y1 points ss 3 sub get def
/x2 points ss 2 sub get def /y2 points ss 1 sub get def /x3 x2 2 mul
x1 sub def /y3 y2 y1 sub x2 x1 sub div y1 y0 sub x1 x0 sub div sub
2 mul x2 x1 sub dup mul x2 x0 sub div mul y2 2 mul add y1 sub def docurve
} { ss 4 eq { points 0 get points 1 get moveto points 2 get points
3 get lineto } if } ifelse centerdash stroke grestore } def

 /pathlength{ flattenpath /dist 0 def { /yfirst ed /xfirst ed /ymoveto
yfirst def /xmoveto xfirst def } { /ynext ed /xnext ed /dist dist ynext
yfirst sub dup mul xnext xfirst sub dup mul add sqrt add def /yfirst
ynext def /xfirst xnext def } {} {/ynext ymoveto def /xnext xmoveto
def /dist ynext yfirst sub dup mul xnext xfirst sub dup mul add sqrt
add def /yfirst ynext def /xfirst xnext def } pathforall dist } def

 /centerdash{ /pathlen pathlength def /jj pathlen dsize div 2.0 div
cvi def /ddsize pathlen jj 2.0 mul div def [ddsize] ddsize 2 div setdash
} def

 /logaxis{ gsw /offset ed /hashsize ed /nlogs ed normalizeline /rr
ed offset 0 ne { /offset offset ln 10 ln div def } if /offset offset
dup cvi sub def newpath 0 0 moveto rr 0 lineto /lsize rr nlogs div
def 0 1 nlogs { /x2 ed x2 offset ge { /y2 x2 offset sub lsize mul def
y2 rr le { y2 0 moveto y2 hashsize 1.2 mul lineto } if } if } for stroke
width 0.6 mul setlinewidth newpath 0 1 nlogs { /x2 ed 2 1 9 { ln 10
ln div x2 add /xx2 ed xx2 offset ge { /y2 xx2 offset sub lsize mul
def y2 rr le { y2 0 moveto y2 hashsize 0.8 mul lineto } if } if } for
} for stroke grestore } def

 /linaxis{ gsw /offset ed /hashsize ed /perdec ed /numdec ed normalizeline
/rr ed newpath 0 0 moveto rr 0 lineto /x1 rr numdec perdec mul div
def /y1 rr numdec div def /offset offset x1 mul def 0 1 numdec { y1
mul offset sub dup 0 ge { dup rr le { dup 0 moveto hashsize 1.2 mul
lineto } if } if } for stroke width 0.6 mul setlinewidth newpath offset
cvi 1 numdec perdec mul offset add { x1 mul offset sub dup 0 ge { dup
rr le { dup 0 moveto hashsize 0.8 mul lineto } if } if } for stroke
grestore } def

 /dashbezier{ gsw /dsize ed p4 p3 p2 p1 dsize 0 ne { [dsize dsize]
0 setdash } if abezier stroke grestore } def
 
@fedspecial end
%%BeginFont: HFBR10
%!PS-AdobeFont-1.0: HFBR10 0.6
%%Title: HFBR10
%%CreationDate: Fri Nov 22 09:13:31 2002
%%Creator: Harald Harders
%%DocumentSuppliedResources: font HFBR10
% Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
%%EndComments
FontDirectory/HFBR10 known{/HFBR10 findfont dup/UniqueID known{dup
/UniqueID get 4214378 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /HFBR10 def
/FontBBox [-77 -223 1049 751 ]readonly def
/UniqueID 4214378 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (0.6) readonly def
/Notice (Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de) readonly def
/FullName (Computer Modern Bright) readonly def
/FamilyName (Computer Modern Bright) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 43 /plus put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AC06351EB3A0C388F7EDE3D9D355D9933DBEDDB5162DB2
E065C95E6D27BCABD3175EE1CE0E7E7C00571B5081E595D70C9CF1647EB0F53F
7298F407369B5B2256D99F3ACE73EA11EA8AEF444CC2B95AA8888CDDD54FAA38
349925414B53EBA844547DF4B6776B552C3A8A5E1051C9F8E9F2B66BB6A3061F
C0282C9E8CD03BA95B247F97135B16F1DAB3994CDDECEE95D123686A5A904415
F44529729B8D918A05763E3E72ADB48EF91845262D727C5317E0EF57B941CB1E
F30E5BCB083CF9DA2934BA93AE9F58866761F5A6F06AF1593DC77775DCF4473A
1D9EA86FA4AEDDFDDA0862C71F7D6549EBC1D110ABFC616EBD848228C8C15827
B05174E11F2419EEA608A97607D38A899E0C835C7B87280FE33D83D12F9C1412
1E2192BF3FDDC35FF01837DB532F7C1E15D4A0FDE8770579643DFBE83F67B8C2
D5CF2F090455080C439E61514674B8F7052D1FD58C7CA74BAE5F3B1BCA3ECB96
DD1881E675ADF443DE3A105AC3D890DAF756B1970EE8DE34886804D790110FE4
88D09F26AB9A1BEDB993E313B478C5F3DCC8C4CFC410FD66134C4CED480A19C9
3FBA1B91D9B26595F4BA992AEF7035B0EE0C9FDD8C6B795E560D7B1CF90555E0
7FCA6CD43A263520F8F243E6AF9DD3B460124F5F78ED4C782899A87DEB5EF1B0
CEFDDAB76C3DD587301FFB94B17AE0CE33920ABEA864204512AC262882C7F76D
ECE373813F5120BF4508B8BEBBDAB1875F3593F45A9C0A57129453D006E389F9
25BEF5AE2780AAD722FA2EE02741E3BD050CAF5A2EC30D299986292940FC1F7C
BD69A7AB9006DA726370135CA257245DDF0D2F03362574EDBF2E2A02732A92EC
4DD041943F33042BC4E1DF12D6A4D6F35F9BB9E3A052F69C780C228DB8BFAD88
1223220BCF2A72B9C0EA1C6D37C37865B919679905395BC6E9DC477FE8E3EA66
E6F07F32DEAB29245E7746B7C4C48029F58450663E0D09836D5F4586EDA35280
21BD85B90D0B37D12C06EED0B7DA9CA40093C9168945792B52D3DB9933B14C4D
DF3DF2F006C0CF10F44DA736E1D7487E2406AD3022589EEE79879F720905D960
6AFD5306FD051CBAA805921D4EB17F3A18FF49ACFF0C3AA865E9083BE47FE13E
0969E8665EE04DE6901CB67B0A2E1BD10148DE9533EB17FED41FEF2051B6B912
6C157E60BC4F79B08C6413138036806C80A87E7BFD973B3DCCF532090E2E40D0
BB10D34328860BAFBF6E9CF01B263DBDE0E01FE41C390FDD5ED6D32AC0B1BBEB
8A45B58C7FFBBEEBDBA438C1A3EBE96F312BDB3C29300B504B58FC83095712C8
C1D9CBB764326FE4AEAC455DC341AE79513F1BCAAB43DC0A3EF19AC8339D3CF1
8964AB8DB67D0C050406471C6CC935396C2E024439678924DD6FD5E2F92E3ADD
99247AAD3AC147E53E3BB555D8B5A26F9F97527344487977C3CCFD450A33E2A6
E0CA3B
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: HFBRSY10
%!PS-AdobeFont-1.0: HFBRSY10 0.6
%%Title: HFBRSY10
%%CreationDate: Fri Nov 22 09:23:42 2002
%%Creator: Harald Harders
%%DocumentSuppliedResources: font HFBRSY10
% Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
%%EndComments
FontDirectory/HFBRSY10 known{/HFBRSY10 findfont dup/UniqueID known{dup
/UniqueID get 4214393 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /HFBRSY10 def
/FontBBox [-30 -933 1117 775 ]readonly def
/UniqueID 4214393 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (0.6) readonly def
/Notice (Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de) readonly def
/FullName (Computer Modern Bright Math Symbols) readonly def
/FamilyName (Computer Modern Bright) readonly def
/Weight (Regular) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /minus put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AC06351EB3A0C389A3D2B08C29F4C9FDB187846925F2B5
2AB2BD00094110ED80B925CD1B8DE5BCCAFD453E80FC63B3534FACBCD94AFD5F
4DC1E22D1E45DCBABE35C60DD1E371BF9BFA478F9EB5985B4803466A216678F6
D8097D0361CAF8C35F01B468ED715DA2C624DC4B7ED560BFDF6702CF2BFA999D
A55DF650943CF3633A742AEE2717980B72EB85CB113D30643DC2B4517A1C7D20
9DBB075BD73053334B99317BA21F3EB27C1BB371F9AAE2C78241A633725E5645
B5A0DE302356DA3C6243565EEC09189F9F616DC3D26E569180B058A84EE78330
12CF0D9979FA09AFFC01001D1750F464971FF09179E36F503EBCF39EBAC9515F
74ED4A8E3F5DB0C958049358444D7ABDE718D8FA4C201C1849F1997F2397FE6D
6045E4BE06A0EC9F80045DF5A616B3680184BD31AD9C6677102B6FA3B947EEA8
03D809EB13970F0E5FDDBA29205FB50C727011D9C86C3266BCA400878BDBD73B
C861715E1ED15198004557B4F71EE22F61394942D7F595F3F01BD340D531B65B
1A9DB240027F76941B8C98828F5057C92F931E0C60848B3BD99DBEFD3A1745CB
58159E6B2B404234554570C76E1BBBDEE655A16BF4283D1DBF81C86533AA8C62
36A7C8540E02A214BE5FE765A2FF645CA743D7CE944CA337BBECE8E527CB866F
057FDD2D4A1F2FF3956EE0AD72AE8869CC364FC9520716556214ACB987F7C3DB
4819909689F9A57F50FBBE025486BBC2927C27D1B32EFC68F214A7ACBAA49014
40B9F8A9F0F3465CB5581D00A5FCFAC0A3E4608243460DC0696AE5F73EAD0F16
AD6BE13E4886F7799F7B0157812A995D6F4EA5343421F2792D0336E5BE974F4D
13E27CC27DA64761FC5B94EEA1FE4F6C0B642E5A562DACFDE349DBB58F7153CE
D71133AABBEFA1C44174D24E876D6F839C172FB878BF07CF71C5804FAD077CE4
46F9320A7D2DF9076CF0E82A89E893DCFF75D67FB4D31C480E260417E57A71F8
EE5993434F656B91A5045C22677DCCA2E699D20A48004296C0B983DC344A5283
E91629D9A84B36A281975D423A3FD334FAA1B3A26DBB4F3BD95D810FFDA5355A
3D3C89C46F7BA89CF567FCF05F31EB14356AB76B6B7D6822F9FD61B9BAC781BA
F7CBDBC8D72CD0D0E71E762F8BF0F43C8E6AB93B71886618B070D62AA97F9739
85F5F5416EC63F204CBFF89030D9F51B30B8B8EC408E7DAE2DAF900B8433100F
75A7DC39EAC75908A019533F5EAED42313D932C2F9E571261948DBA7FA2D5DB4
753110DB4AAD6701E87D63F193772D833034F4C033C768E2D3BD7A90D8C11CA6
BF718FB9B6A3BC25AEDBDB2EFE98DCC843881F129FE829EE639F65CC96F9F193
B263264D3D1510A49BB57170CABF7BADE609425251FBECA70B92649C40736C1A
75F76BA165CA708EEBDBEDDEC9A6AE1E9534AD219E7399E3DD01090A40133C8B
E9CF9D30C5D3C59E258BA447C2845DDDE0E77283968C7008056A3E89BAD059C6
3B08811F158430FB8E9B975A25B63F479EE9D1E661B723E8C60D5B639A0D9C10
A37474212FCDDA1AF23021C886964F4ACCCF1F038EB77BEA50A6784DBF9C9A6E
54B1599CB56071945DD8A5A78F8A6C00C9D9EA668D8D8DA57B4A8659E4B05B8C
632136CDB2BEAE2D929B4886278FE141ED6119A316E022946608BEB0BE34E45D
860501F5CB27F361B81B9CCED5852585EDF4D5D0A7F2CE85C100C7CA86663BCB
533DA5DD3CF197131180977E65DE926F3F0AA846D60C893957B2E8F485D473F0
991874FF8D1A0EE43F0C0B9008494F0C756B1EE19B1C4F1957405B11616B2433
AE9DEFE7FCAEE47D396033487F2C0FD250DEBBA089617C15EABD9A64DF3D5252
9F65583F1D7D3B51CDD2766823D9A004FB26943DA7E02160CB844AAC6479690F
1B34851A2158851388EC86783B86D8FDE3E9658CBEB52A98D3C4156DDE3C5E05
F7EC25103C29C3C73E377086E8EDE8468704B8A31A5DD62767EFA1620922AB7F
01FB162D5D0D16AD9B837A68FEC8E4C8DF9A63B06F8B74E511412DC60AF53E07
A8EACAFC4047173232826DC339EF3659A94BC14CFFCF574647F28FB6C3FD29E0
0AC5E268E181E378EEF9479B9226F1CF630A3C9E43C03A252C9A07968B6F99ED
6BB775C67B5883E69E051D193942A0C9F3FA3DC717F5B5B8F884142529CE278E
A4C794E2065E30AB1D47E256BA8940371F130799C8D264D95C476F961075C115
8814F2439CDFF9099EEB811ACB4A6A0A07F06D7A7F9FC0F0065E0FB58675A365
98FF488FB9D063942C5E89C9888C2776B329C0DD303CF11A13FA09CCCF986F4C
A9146FAFBC36B14DAF84EA138A6E3DD99A8DDB4083D2A5CCD609E3658CAF79A4
A279319FBF212EE60F4B182C249E25DB454EA592C3279658448506B7C47B95BE
C31A1010574EA712397CD45E8F8D1DB44364DE7934D85C6F059C150CF354020D
48B889CF668644F1279B6C2D507A4A307603A3767A94A2012A79BF9E134A75A5
E217D6C7C4880F06880F2A340AD3DF0B3005BF2B804DA18047E5CF033BFD7DF9
F08E41F3959FF7A2E931648804971548338B85EF6F2EF3A6CE2C966E0D634C7C
B6D4C90F9F4DA8092E34BDA477CD9F47D84EC7AC98FDD0D2AA4066F312D2F99E
E531744BCFCDDA53CCA87EF2160E46C5A3BEBE8EB51498D48D4391D49F8ABB52
C07529AC10FCC547479CDAD6BE91631090CEEFB370D06AB4108E00BB5867959C
264D393C92C918BE4E075FD26B574F39893E381A2A653290FA3300B3F23D21E6
327E23DC69E66F95DA53CE57D81E8E87D11D50B231085704FE06E701DFF0BEAA
0C154E10836EE41450A5485B520E0A99F257CABB732824D33768ABD917363021
DC112A8D1A58725ED97990A5E053D9B850AFD9D8727A385864695638AE17A3C0
ED20F87555E4AC1C1CC8ACB234DCAEF25263C2BB0600FC084556BC4E5E51C971
D8FB09EDD2830A6477CFC0B654C709C2313A3310446E137F42EC069E3444D040
4F30E14CF03A80BC60AB602303D99E748377204D09D35AED0EE4495308C95CB1
A92C16F13498B2DC0EDD74DA17A79B656ABD2B695C3D10CA2385E9CBCA858232
5DE3B0CD594CC33D7F266A9A94E86140990B49B32DD325E0459D72BB92E56534
D78ED70FD20E32D8B37496C02D6AD0B6A6E3DCD653408C131A26A63F4DE0083A
CB0BDC262C80298E3DF80E2E26C6574DE1B62106B0B1D4FEABB0CB6A5276FC1A
1EEB68532565B6456A3AE58D6F2AD9EAE1BDA3B881659DCD15ABAB6F06527529
2F0DCADE328AD57213B013396FAF3B81857B938E19A3E8358E7E78723A3E6873
F21DE4AD82EB68274A2E593B66121C804052E160564B774C4DB28FB9AB8E531E
BA20B2F7F2F2E4999833E77DED8F07DE8BEC19E675AE50CEAA8FC5C4E6E8974F
E387E3EF400BC3305C37F3E88C02CF0795429415DC2E6972080D4F8E392D11BF
C05338496503336801664156E49F7AC35A6433D7F977A86ACDB4D7866DB52EF8
F258951F17027C529033141E1B7EA406A67EB25B4CACA2F9BD1EC6EF84CA1DF0
E7D6E8B112C11C21EC6822203983EEA00EF70FA8031193BEFF400CBB356B1600
BB0142D5259C2FCC8936EB1201FAEFFCFF2F9A14138B4E4240B5243331C1FE46
628288A7E43B1FDFBC0F756DAEA910E45AF789223BA7DB6B8CA954161FBA9A79
DBEF4BF928606D25E3E4938D156DC142C82C957AF6C578C561184AE1C3BCCA63
AAD92EC9E70D5383D5E3C21C65CFF7FEF4F134715BD9AF6567611C13E932F211
85D90EDC5C03481365CE6D5325EA09078D1BE1C5DD1DDEA4B04FDE4D7C66DAD2
30F79B06AE592F24F1F30FB7AAEE151E286274E78CA46A20B5046A1C9FEA8E0D
064A38FCF06C480832142C158024D7C482ABF903ED2233DC9AC1D26F4FCB7413
7AE4BB5C4D62C206A3A38C98C1A56D9AD6191BAB398D5BE4CAF9AB1D16F82A87
CFE21F7D4807655ABBBA6E23F715C59F1AD52932995272F01AE7B4D8BF88F86B
2A7286138D5E13A6CF20838C0A9E83F09D0B15EA6DB9F2F723D119A0BA2946A0
C5E1D3F1D625C5A9F3DF150A4F7123AD484DF8DC8250986A9047D859C9AD85B4
94CCEA87D291DEC1A823B55457BAEA5838ECFC91A90479824813D10FDEB14C22
E58E845F3558FA50320E1A87AFD72E899A10A2E0EC0AEF121E6D8814EA0126BA
173E96DF3B717066E453211966F7B696A9F5CE88E44943AFB5306B4D79577972
E9BAB8F7D7C6065C5B457426873FB72E1DAF1CF3B66FC0A16F52A79FFB570037
48C7B672140B2FBC1AB297834F01E64F4BA2D69A38046FC2215E8D3992958F78
2323D7D501BC8F9C5112A457139CE02E6612AD58B2A12A05C410BEAB801E1F9A
A48A1CA85E57A7B85F4AEAAD8C0320552331B68AF7CEB7B30025AEFD4792E33B
2A99F8B179514A91121138760C350B8D93A831A359AD3DD163F0B12FEB004A2B
7AE6A5DE0E783D4C6647392A67C8CAA0CF0A807D8947D5B903A0C7287F082133
0D1B362390EB2BA56441CBD9A5D7229FEC50F2B40BFA95A27B08DED2CE351BEB
CCA3A88FE2A1A0628D014710BA56B094F733AA7543E7FE1155B0A1EBA1FD55C7
C5556FF77AC4C8D1D6A81458BFE1A05EE51DCDCD40E3BEDB52E22AC1CE9034A5
B6029FB568813246F9DCC4EAD90691E3001AEEC18CFA223DBBA0A8571BBE229B
7024BEFA6A7C4B0682411CEBCAB0048A75F514D8FC46FF66D88F844006DF7589
58F18088B2200B16827EE0A0409E344799F29E9C8BE6FDECAE77CBFDE4A1895E
E0343AC4C1C93D71C717048E0BED79E23F52FDB84C58C6350BF589AA2CEFB240
00557DA2F98AB3D90BD5B07C3F4DEF964BD92C22BFE6E5CF9F7E007574DE25AE
0297949BA9ABB267555699B019E75ADE4DC665F0D3A38CC1577A407D073A5E48
1509E421B159CE3712059E1ED54A61D47485CEC3BF822EBEC1EB0A78692D9540
86CE1F61D0FB7F87DB0C0AC8DFAAE799F9A26ED03D2E8DB68C471C2CD9C7DD9D
A7630B6211AE74D5F16992FA6E0EFF348C8EB23B8E2031A40FC88FDA8B6F4F2B
D733276AB761C4BC18D2EF1D721D6B382DE1F939CADA436BE0E30C30BCF2D3BA
A38945354AC0852BA28E6ECD35B3255F6EE5B0DFE1D3FDB0CC3927F5E3EE58AB
4E1B46E3A3E257034B3E0F82F4203CA4CFAE6734A1EB5CB98BBB338D0B9719E8
FEEEF964C24243A051EEE50C87CF27A190423EC8295CFA008E0BA26458C9C623
2B9C15984CD97B0D3439341FB468B81DC0E55980DFFD48F8E86F06C04D644896
A2301C2F43ADD86F8B1D0F4E78ECB5CCF95CC4E71B3EAB69347C90B9EB53EF73
9E7E58CA4CA61E07171B98B13B0D2C428D6D4AC87D627ABD316AFA171FE49152
8FB17DD5716AEEAD2AFB7620E88D5B5D5A6475CBF057D78E43A0DEFC49C6640A
7FA8A0BA149C9D689F8F625EFAF5847ED6AB2AC304BFF4CB07BE12CF585C5537
444664D30C026FF534EED7288D3C0AAC8005EA3F1E2A374AF9844A2886F5E966
D3A0DF23861A6B43B07C74E63537D82E25565DB32544E356B033AAEEB9093D23
FD1B40B0957FD216A71B44266EAAB4FAA06A4C9C78DDAA606F635C993AFCC728
E530EE1463B75885CDF80C39EF2A71597C6E19810440F44A04DF72A396294848
D81DA3E80492A6B671EF6826A700CAAAAF34353A15DDFB7C3556261A63C179CC
55C7AA58B24958CCDF01C96AB875880D95904929D10C162A4F24F31012A6BD44
44E21452FE85ABD4528B7D1D2F7137F20268C985F50AA74751F51FC9D7F19DB1
E18C1FA1CC02083FE7E955F172F2AD521BA4B240A636B56B6C04C9A692EF378D
236CB1DC0EB2F6352599C794F721BEBBAD4F091F65BD8CA41FD725F4EA647507
173620F28D3104CA062EE28EA46012F45749E091C90ADB81C2D9FD2A8A21ED01
AF6DE7C1C3E6CBD3C953ACCD525A149DFA7D28D6927EF177DC32A3EF6E801EAC
02C54F1997B209A99B4D798C51464A6A2F04531115269CFAB2D12E943CF9601C
121A138551C6CFCAD42F0DC23DA4815E6A84300445A5F22F7B5E85E0DE3ADFB6
6E2972F4D573DBB48A6739227F4CAD55CABC0D5A7352ADB3874B816C0F4D975E
49FC5D11F77503B8B1C6633347F8807C581544575C81A4322A6013721A8A8B8A
4FF498D82E60EBE5417D8A4F26C5896CD2EA5AF8D721A3C6A9DEFBB670C711B1
A8FF36D4D23312B5B5C3CD5C2432BDD74F36E9A80EC982C34AE71D81091D928E
04C651958F1101D211038B099EC2311F7D7B8B55AD34D8EAE544BC5C0948003F
C6FA8E7A0E6AB39F85D82113ABD83A5698888273DF8A13FF22BE35AA470A339C
6B1F193B114C3213A314F33CFAE0F8CD0342DDD17FAE2552B478A9FC5CFA475C
627525F1F9B9572245EE1ED1A027B27DEE26EFCDD2E1E9BADE3AED4EE9383CA8
E60216955135DCD529B3D4B6313BA68C71593D934D392EC79AA034DB63446945
CD81DE66CBCA4110D1F819795F2519D949E5B530FD668D1711EBD7B1CEEAEA4A
89A7C9196F558A37B99CB6D7AAA3EE2407EFB598AB799611F9A5309E2996D1F3
0C91BA8331A5E445A23461D4B9A2A05B1AC0B3737D805064CE91AA02BA90AD4E
0A1B94DE44D32E130C805CDC1A408045CF2F7A039637E00FF495C48607C78E07
599AC81904CFAB920FB6681BDA00FF985C6EFC0F3F41A28C7456578A4D3927AF
AD17FB28CE17FD10C133766323C13111ACD748B0936CAC686C6A8A1529BE147F
1CEE3C6E3A9A979B88CEA35A8E28A01D0944864B5C60F6D541DD53C006A5AD5C
54A214DA00B2EFEEDC79CCBCA09B303407A34D2F27B0AC5CF9CD0CC5324D667F
D7C0A368ED4FD09A79E82CB0EB20A37922285B2D9CAF5E37E86D918F65A2FF3E
227DD1AB8FD61F139D958BBF0E621AB7BB35A3D545B24074B8C77C5FCFA1385B
881D12CDAE74C53156D092F1A971E740CBBE5C8AC34F0DE017885A6845127F40
2AA06652A09F926D0A5059AC7D0A6146FF49EDA2D742F8C83E733C1779AB236B
D5B2E75E8E105391146840F1C3E9D0C3807358BB10A6F3C7FDB73DE8CD081B1B
FF8DA0E6E35EECF7D0B6B797D96C8E3A2AAF6259950AEB94BDBE2329A1FB2BCB
A2C432898BDB71A109AE470CA37FFFCAAB3877E4C1F44F97FD223E0D51B495E2
87081166E43B665FFB903E3689222B71BF427849E6D25084EF7CDD80878A0305
F898B7CCED2374099E81B67BB255A1A8D73C59B7F30FD97D38B13B76570E7C13
7B60A6EC7E44F0A807375619BEB450E456B409F7C6085BA2874E038AF1B7B7B5
DCDDFAD3181488A8DB4F3179FFB47220A737EECF99EF3B73B87A9E2CD5EA2638
8CB4294C13D666C3E9FB48FB954363F0A7E9944F93B27997ECD296387A98E980
3FB46E168665BAFF7744201225F1902141DA11C62DAE39553A7A28CAFCF58572
F03EEB1D709DAFA880DB7B200FF83176006D7F62A750D7DE8C1E7EC3DCE7AC47
3DD63C5C50D28A9C8CDA3229B4A495B65F8A219B61B09C0FF0A4E00FCA622298
36A7199E8F0D3595D25551308FC89686E252E8580D4AC3520A32C22925AE95C1
C4DD55BB8EC79701BB35995950CB00A56904D6E021EF551CF51DC02F86DDE919
FDB952BA6BF56D3DC8C4527837DBA4C9362684651B9D5B09C17883D35CA9E4AF
287350B03762E19C392666F488822C5F8D2F556EA35114D0B8D5DBFA2F1CA5C3
8629390622627FCB5A20730A4DA7E6EA76D91F45AC22819D838D580A26C51614
CCC4AB646486F07FBA10C2EF19C167EEA8740971713C9EB53DEFD95B44A00051
F955502C90EA0AE50D61BF19E665F7B0B1C9269A6E1BAF8A1E6F9F07DF237FD8
C4A1AE072D1E66EA6A8945A42010D14402EBEDFF0B144B1C9BD22D737954CFC2
969B1167135C7417CFC430FE7C8016B3ECBC8577C2A05B4D68FFA0100BF564B3
DB31B4D44457D2C05DE5DBADDAE7385F40448804C7541E7517809965A4691664
E373B5C24B3EB36CB7D5F86AB267E1CF113AA4E475B8D83F6BAC2D60811DE692
71977AF44308CC4D9788C0E3CB5664C60D8E524A15FD6DA78345A96B2BAFC3B0
048647DD26E13D6CDDB49C4A6C11E5F309537197F419E6722DF01EF3C88BBA1F
CFFAC090CECC8F39B64379313F142FB8EC2384C3A178796E87DF54C112D7813F
7271A5474438A7CC380735F029CAD734EFC0B94C4A58600D51FB4D89FA797068
AB8EE040F4BE6FB515312A345FF18B169B121155CC018462884A1692AC598ED1
6C47D16F57DA03E70605C643EEDDBE9C697C5D32A76F096ECAAFC065535AB32B
2E7405713A9B31042BB5A1A3B74395F8AD7A723EC106529828D6CEDCBECA38F7
FAE8C1363A6CBD8AF8B8B9D1F730416FC7940668F722EFB7E8ECCE37D4138087
D9C6A93A6C0E4A2AE7B930B69005A3A2C1225FF0F378D08E56B987062BB57237
BBB3056A36E97E399A791E71AB4D0073D71DC38239BC688D3F5F61CB43AE2A57
2775ED9ACBD9A9F11070BE452B7541ABA3802CAB0C3CC77027D8A3C0A06A48BC
CDF5D6D6770402B4F44265048F2AE84F226220DFBA0FBA985D136415D0F742D5
70A744863FD8EA705890890AC5BC2F0A068C72B917BDE539B8BF0673882164FF
2F57FE5DDAEF20AD718ACE5C18720E3E3C72B08FB19807710498752E1B190FD8
62092C5D24CE3B8037AC8FDD3EA6878346882EB5592535E911EB0BF8D1884589
3F59221410C1727F19AAC361613A028572D68AB9D20F3ED4130D20D9FCC855B1
2516816675EF30C31A49FC51C058073F50E9C30475DEF8FAEC6DA2020F11D0E4
9CA2A7579C6C953E21A4D7A77CD78605CDA98564E9D72EEE952023326B44F5EA
5E31B2483D01113B2BD7AD0D11AA64DFD2AD7F508215D6B59D691CD14C8650AD
20A77AB23CABA052E588354EE7E2F89C2ACFC08CBD86615AB5A60F794B37C95D
D65D4F0F6A3323EA40EC26E57D422C074B3CFC41DE46C7FD64AABDAB32B041F8
A0477D201123BE9F3C493B8D386052B422FC6A7D84B8B804EF216233711032C2
BC229D1CAD4F5A023C96DFA8F4B455EF
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: HFBRMI10
%!PS-AdobeFont-1.0: HFBRMI10 0.6
%%Title: HFBRMI10
%%CreationDate: Fri Nov 22 09:20:38 2002
%%Creator: Harald Harders
%%DocumentSuppliedResources: font HFBRMI10
% Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
%%EndComments
FontDirectory/HFBRMI10 known{/HFBRMI10 findfont dup/UniqueID known{dup
/UniqueID get 4214389 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /HFBRMI10 def
/FontBBox [-108 -222 995 750 ]readonly def
/UniqueID 4214389 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (0.6) readonly def
/Notice (Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de) readonly def
/FullName (Computer Modern Bright Math Slanted) readonly def
/FamilyName (Computer Modern Bright) readonly def
/Weight (Regular) readonly def
/ItalicAngle -12 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 87 /W put
dup 98 /b put
dup 116 /t put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AC06351EB3A0C388F7EDE3D9D355D9933DBEDDB5162DB2
E065C95E6C199FBBABDB5E3C86498B8A2FE34B3617A9C822EE3C206791F723D3
0FA03647B20FBD0D378A55534399BC4BEC29FA576B802D7DC4B3B4E912F30B6D
0C18498C6551CF3E11303E1A6F632D10DA65C085A8FF051316C073571B4CE69D
D554863AC47907AC2BE34DE4203C8A78CBA2A739507E02D313E9A7F89EAE910F
204C63CCA017B73E158669002913003EABB317FB508B2D85A316BE8C707249B5
FDD5B61C1906445E2B04C6896A8E764A825A75424F14E0CD2BA99AC4746E8E0D
F4C4C682F7A0900A2218135DE5E58CA35D1ACB83255F683AAAEF8092CB082A8C
B0D779673F065D7408FDA0804E12BA4729806B39E930A9FF2280D603F9F2EF10
67461193BF703BB5383FFD536F67E20F0A88A204DC683CBE272E7E8489AC8866
30624DC40BE31A47B8AB64840014D5A9F629CABF603B62268885D2161433636E
DE38867D622F58F1DB8CD8B51B88E15F16C6BDF163E66F35C63BCA841D5B489B
6BA7886DE7EC684773BDA0F1AD024A3C82EF259B6D15D71AF7ED9597EC5F4DD5
84489A8B5158381E30DC8ABD5BE39B59C1A5ED488297CA2191BC3437F31CA754
B0DB2112129FFD863EDC2160A80F7D4D943929AB612350F7BF8AE375F111ED7A
9833EC6280F58FC4EA0FEEF49F3B4C15BE9C4712AE4DD13736DFCD0F682D7D32
4F135865A9D0ECD664C6B6B2941B7B85C79DBC210002F76CF6F57AB7D695F17E
1EEB970BCFD0FC394C016EE3E1241018F7ECFEF9F9133E7D3F813F9D8EF25173
41CD5027B799617212EBFA51F6D1291B357B9EE787941BA6D88502E7F25015E5
59877D7052E6F04C062050C9350C78BE68FC3310AB866F6BAD780CBAE845CE86
E0DEC7C0346062DDDE4CF5FC2E46BF916DB10AD9D856447F138F35B9E765834F
FEE3B4A273720A6DEFC528C6BCE8453833E2C176ECF1F0BF1B766B98D882FDC9
79CFAEFDF8D608E2327A19ACC0A9034B600411DB1C1CECFBB3D358C99B87F2C1
66F222CEF2E056AA29A1495379A0716AEF2EDD9C94940C02D20A43E1C7278B67
1681ECE3F220A7CCD7A61F7D638275E0A1C9709BDA8EFC357C6B67EAAACFD6F6
FC503307CF61B15C126262A5CD3EEC6A4B47B8E870B048FB96EAA43DEB2447E4
C2DC9A1E87DA5FF96B15296257FD791D642DFC937F6CEEE01B3B64A3F732908D
553C494E1ACA34EED4E2A18B8DEADE26549988D98A071007FD60A8CEA754DD5D
1CF9D19F956B192C593225B5186109D3E6636E87BA6F24EFEACD1F06A29DB1D1
F4DE4C0AA6781D61C4B98BB30F3047600AE9A238DAF7B6693BBD4CF6D8B6DC1C
56D854BD6FC9ABC29DE904710FB57AE2D3D37E6DE597DF96964042653B056895
0B5D02186B019BF08B8970AFFE725EA77032B9E9125E89A42E94B34B777BD66C
EE3314D4E720A073D85A7744F611F58EF39B08CB435164B147B5D8C76C232F38
AD98588905BA2ED95D450CF65DCEFB3614AC09EB2F118DB4528BE35F52CE59DD
F9FDE381057DEE71419F92E03B83E56C014B6B9A911513AF43380B81D1135B98
BFB97EBF9402FA6967D7DE9369B0692374CADA1F7A810A9D9C5D338D30ABC2B0
16D41B129C722678C54F83C0A679E3FC4B635A1272241BB1A2AECD349D90E7EA
35BC2FE21DF1C2285DA617FBC8988C00C413FADA83672E2D025FD98D3EA9EF3D
3607B7F8BCE6E3C90D7F05398B66ED0AB9CB898D41A707D5F093C49115196746
DA3FBD606898041893DC989777B20975C01E14524F1D17D4AB7DC47CC7DAF3F8
4240C9C118F13C8629046599894F3A4F4029A42A924EB7311588CB06AC8B4D15
2AE6C98EE7D3217350EC9C221291BB4A3DC7AFF5534F2BDA9F17CAEB0F2E2DE9
397CAE4D099A2A45A265C1878E3B66D1D8F2AFD2F43433E23379654245D3D447
E4CA328F1BA7B183C2B8080C54041471BD50D87AE182F1A23C752BB1D241D5DE
D04964B2B851ADE41385F136141D968262CF4DFECA20C869C409E18196B50473
579AD4E6314016337C70AF58A0406DC912689D867F3E7F11985B3FC6C7008725
17A0DB18FD08173F57C9D09B2D3E46C963A95E4C6B0A4D4C5F3122593EA3DE1C
D2AE6693C7D4554882B6C7FA5C910E3C1DD5378EEA45326D211E0E0361149A4A
0CD64CBEDBD6E92D0FC5605CE5498C607810694E0F8C52760E7159ECC1D2AE32
91689119A4B330B2EE9E525101BDD58972A870459125103D25369DA36E884C44
BE8B4BA1C8A1C94F1E6AFCC4A89445F753F25A0CE8FA4FECAB9A050E0DB4DE2C
F5635327E3D19FC89FF70D5163FDEE0D44DEB5B2A3944AC976F7065741B38B3C
39C3979DEB1FA2835657F43F2C256663D87ACEB3501304B9FD91741B6C5682BB
0E8744E070F0A2EA93800D21DA8926CEE57E277EEA7EAD22F0391B94DAFF627E
7E5EC9FC3BB9FCF3ABFDE912A79ED5996C6DEC012B89C2FDF1B829956786C167
FDDDAC20FC72BC0D18E91599BF746CB88ADDAECC286BB17FA8737438370F000D
DF70A6ED38B43A12E510B8D6A1DB5F1CBBD4CAC8B79FC51FAD48B0E2F94DBA82
03E8F573CB5874C9E0ABEE3FE2EF8B051A00491CF8ACA729587DEE21D91292C7
8DCFCC858892DC1A92EACA0B64355D0B52625574FD65E81ABEB5EFDC731B1441
82526AB15C78C3F7FDBCAE79784E438A2B3182547AF16B1B07A6990A66535999
74D954A0C45D957A8C8FF88C6299440E4A8B0BEDFD9DA780738429C0437EAEC5
1106DE8F93B584C085C1FA2AD48F97EC082FF299B22B6C39C194971A13137903
AB3BD96FA3B67708220F561303A446D252B1B25CBC135F011CE1A10F7553F10F
FCDD9936396ACF9B0595340612476C5C437ABF14EAE55C0AF4FE8C2B95131D9F
8434DEA9DA007F0FEA496B1D9C7C52CA038433238110D7A78597090FEBB1B706
A8B53FA6BBB25C0F8CE8E8EDCE6D6CE4E56581A61B190FC65B46A9C7E729B9F0
39C1B8C0EF37E3FD4C096B36D7C1471D5651DAAFB709B49B125795EC05DF5398
3F2610C7A35BA9F21078DCE2C2AAD3A25FDB8836ED743E515A1C6C1541CCD60D
FC3DB292245623C531EB82E03F269ED8720C2614CA1EF5DDCB9A9298F809B940
01C4167D69DA919251752F898E6D493888764FB7DAD6B7DD35FE64AA4DF29773
7FA1B280AEF0D1EE9186410E7F427A4936611D71AE0D7397F3EB892BBC3D246C
4E94154B2016425B1A7A3C34FC55B53B5E705B5A5D12548C23BB017E5B3F40D4
C99E1F4FF6D4AAB704BA1E10F810E91E97E8562A4F35C666090A9E59E2FB9127
E1ED2C6593E2B865236ECE1524E8FB1BB4AF3DBA68CABD13DD69ECD0AF6DA92F
239FFA866E63D1878FD8F057AA0ADB9341AE7F1107DE06FD285828A999D95B80
AC01A5CEB1671DEF707D4486DFB2402F62706AD99CD72285CC8F5E95D0F34196
9192AE8B48F25DBC6531655A7045D6D7D355279D9319CC3BADE5557F9D37DFA0
456193E06078CBB61C022B312CA2B3D74DB563458CC6412EF9C5B8C4D285D0BF
02A2A898D38AF64FE37782D7F0E7CC94AD9E9F3434B4F69494ECE226BCA88380
9BC480C901FCD7089041F5C5DEDB8E188529F6DC7A9C923E752BA94909AAFD76
077C0401388FDEF9CF9B0B34BDB181D82A94DF97C194D2302CC47BF968CB1F6D
476765DD1CD2FBB994EC139664E9E278EC58A25FD4BCE68C8D1BA58F1255C59A
D6D59CDA594FCB68C8C5127C4618F4BEC2FAB5114636766D888A80D205E78F88
2D02F2CBA17EDE995CDE74E48EA55C839864A5D45B465CA331D95586930CA2E2
71A5C12DA076503B8198F337A5761A4ED280F37840128111881B35C2C7D6509B
2B749F1409EEB6DA20C70A57129401EC59C99CD51EF50448E8F5D34353C29A0A
37B7E891FCA023EF18CDB84BB5603015772B4C2F1C40944D74403778839F2E5B
EAC028CBBAF92100102140AAA9E97913839EB63B2AE86D9E39F7A45CDCE00565
27C177015E0BEC10FFD659CFC1E95FD36CDE39709B2DD2DAD37A00E505809A5C
E9D124C7604DBBDA4AD77AF37A4C38026C0ADD6F38C9BD6989E8A8C313A7DE26
FC525AB4B1E597299235D3A7EE768F2B480A1C5EC1FDD19830EA5382670CC166
BA0EA444025898A5091070E9358A4B5BEB88E23A18EB30BDE3AD1979667B77C3
36C55C42B7B4599137559B2089AA01090C393808B08ACC4C48442B68B5666B68
53ADDE30FCB28A904ECD3E183C3D1F25DE193F09ABFB21B2744C63EFC978ECA8
C4E3BE979D2B2633EF65B815F9ED5EC1981A4C83D013EAA8FC5A649003996D3B
EEFF79954671C6F4524293FC420941DC87E95DD4E370F678F8A7492C70E418F8
2F032745494F1D61F8C0BECBA74CC30193929D4F5141B0D6655A0CE9AD64BA34
09E0AD2E0E10FE45639852F9148A7632F3512EFA7C022C4500495C315D0C7085
A4D489C273001B8DDD2A7A5FD54E47497D59CB91F42FA2832ED3DD9554A76CF7
7068C00D32B65CDD3476133D5AF921FF8724EDB8A2113B791E8A5FEFC242EE48
E1EBB351805B536D044643FBB44F5F9BC8E44CDCB94CDA6E10C8FF496E530785
F71D6618A92F0F4156B7490CA9B2B1B4ED7B0D7BDD3B01A1A493EEAE2D2F5AAD
4F4111C92C199DAD250A7B9E25F5DE5F6C986723E6ED3315ACAF6AF5EAB716F6
08451041990AC546BA6A36930C42194F164B774A6521BD2DF06573EC663C3F30
1D0203E2BD6F5B0DE0851DBE74C69D1667F7AA5E5B3707A18C02CFF7CD88A835
4A4BE15F6364D8B2A55041F1888F708B929A6DE941204F37FE95113977FA4969
EBF973D37BE353D2380BC84922AF1C4DA52CE712AAAA0FC38A42C5CF36FDD694
E1830E19A8E116B7CF56F4EA5F26C2FE08AE7004FBCFDA5650E2A6F2FB2A3F96
E7CEFD7AE1D4169A37DE6119806E10DBCAC6D67D32AEB662FB827FDDB367ACB0
0F9951D2A42DCDF006A4C02B8D2B0D7939D5C3DABA9A28A23AE450A6CC9C39CA
7A47CA1DB46C2FA1AD5E04A9FA63A1713E7B6A8F79AC724A8AC63FD98FD52449
E2718AB593CF82A5DECCA30BAA3A4B5CE0152B8A9D68B1FD64665D7F1161123D
E639BEDD3F356D3159F9823A40AE9BB4E16C57C03CB82B3F896BBCA05C040D06
3E4E40F91E0192D780EF5C386B01F076EFA584965A31A99F20E998242CCAD5B1
D3773D4BDCDD188031E7D00A98112CEB468C8893D26E60BBF8002A43E920D44D
A0A2EF9C3D933EE163A5C433E1C6BA9073C40EEB9A16EBF1C8FEA010D587F80C
EACCD2A4DADE67C76B8B5547742E0A06B1E47E450402EEE3DF8D4B01E216DAD3
FE9D126826EC2DEB87B64A001DB9CE0065B4440F46558857CEF5470999F6B3A6
17F59110A2C02B374671CAAB374E9413E32156139B39C3D54E613D1725EDCD43
7FD264FC982CEF3D8AEC90AF13B5F35B812EEF80029824654F1AA2450D3BC1DB
E5D9D9AA5A228429EEBB58E6B2785DCEF1DFD5D7DD74FFF4814CD9B28BE77095
221702FB8114D22F0AA98FA76B4F9B0BB11244BA5CE2D533891FE20A39605C92
08676150DB464E00C96EAE5A39DF879D8EC86DD5CBC285E67B5040D771B36F12
5582F0EFA67887D10647FBC95C888433F9846AB8D0AE9805FF7654ABAB07748A
2A39C010F5511D13C209B6CC8C59791338B058F3DBCEF3116F6F1FFECAEAAC7C
D0D42619E95BCB97A856358D4FDCE0CE3964A38D6DB1988E695793367F06AF21
D1BE34825BF379A627DF70CADDCA5914FC9B7B8DCBA796C306F32E1BBDD57DE6
CCBC235568B5339DF2BC4A17C1CA0B3D1D5EF88855413E7EC0893CFB58E29B85
F3979C805A26143BB8CA5A9C07D622029ECC2034074343ED2E8030D46D6A81CB
7DA4D13F28967543B28B7EE87294D2AB38CD616D269504032E924B75E90F9E6C
1700B0D29AB5A8E195115CD7BE0E67687980FE92A22D4E88ACD552DAF91CA00B
750A737C63E1FDF6BA283E7DA62045A3F3EB95B89194ECB9A42F219B263C595C
25A5ACDAA6ABA08244BE7886D6013E71C89DBCC6129635CB7C0677963DC75E68
1B45BD97585DDE24B91080ACD10C1F1A186AA6F36EEE710165253F6F1FE6930D
BB028EB1255C28B301912DD3D8ECA29BCF373B00DF38719F2DFC3043D0412D35
2B8B1C4660D23A0DC868C6CFCC9E979A15642EBFC1C9A913BC3B459C494D082E
53D23EE681E4A5AE44DF7C99DC171817F154F4620E3D6FEB5D9337E9004FB796
34D477A3EB341EA95F40EE7B06B0B33A8FD7A096378CA1D0F7DDC4DEABBC8ACA
CE5082E467F29BA94E9C593E588FF473DC2CF9A4DC312500135F29963A9E4004
C042A47B64B3F9ED186A6B2EE09B216A36346CF5E8F8721B10CD41E8A472310F
263725A7AA1ADB3FA770CF22A5981E3AC5552079BEF813CEFFAA1099873922AD
552C6D30366E6F5E2E6190C3A2A4C11F588A1C7F72B80DD9C41B301B292EFA78
D34B628E6DB858E84630C97F1D22D9AEE1A43D87C278398E5A0C5ABD81AF4C09
984B0B56E88B696DAF486379793B91122D25A68754B08B9F146C3DF045ED20C5
56316764D8B0ADD350E618665966AEB0AB0159DE286F0521C03C0FC94CB0226A
A2C0B02D010916DF10B2618E936BE409AC0BBCA917F3273BD8D515C07A694AA2
C0A3E4B661A566F30F074C97AD85DA9D2C3A8473DCE7F9C525C06C621AECC3AE
C79108918C925B9C0D65658B4C11AC2E62A7850FFC2397A96AB26D8425AB400B
67D1914D95B4161D7E47B9FCB0FBB2493B52CD906CC6B2B7331D6FB77443DFAA
AE3EDD2D1915F06652C555DDC1C5F0A262B791BC0945899247E92390E3150072
D899C51D844DA928BBC737C28B54B5B71AFA610D5944F38ADDF9A0964D70C16C
390DD2D9113275345C3F7173A85C5EEA7CB0B359C8CF28F1126A30213AB44EBC
F40052549AAB3B7AFE9FBE526BDD445A5274EC2A322C802770D4DA5EDD00190E
AC88587A1CE54021543330C771EFA1E65A36E5D90DB6161D99C92FAF34222742
5B7354580327B981E54E491366B3C317F1EC8C377581B73C1AA2F992C65EC402
10B02645F024F2F6BE33DBE53CB46704628C00552276940B4BDE8BF5A0017C1F
789A5E1CC9AB4D4EE1A3A18BDF22EAAA457D5A024BED19160E796ED99B5F82AB
D2D17933DD2A6E6B0711415F83358F98C2AF7D9AA825BE430EFB96B436F06FE2
119D8AF2A2290D04A85B82F07F315F180B1725219DC3F77C5C57968FAE08D03A
8E5016525D50AE5EBBA61734B2BB7F236CFC9B0C3D209B05E8FB22993B3923D2
3C15BF486896FE3B398AE560DA86434D4DE01AF1E7A68BF85376D3C0E8D0CB81
93801D5A33FC9BF82C15A698DF89DB01166CC067EC637BB2E4A28B8E63950558
12B50B067502D4BF14AE165720FD7AE5BF9B11674C501A36455343EF9BB52CBE
DB80675A75282ABFBE5868A29E4A72C6DF05988162F0F9102828DED352542600
3522DDBA25EDA008D4CD6651EFFB3C7233F18680B9AF0AE25A96F4508222FA88
1FF53E3406C0135D21B99B986527EA3DACE7D44011A439ECA3E7D7A78FB70C4F
13B5042DD540DDC36BFEC5F2A8DBE04EF457ED6FCD1FE648F68818D2DD4766D2
90FDA3924F70C2C2E2519E9D23ED670D2D27B0A8E3FC69AACB2BC83386B86F44
13114BB2B39EFC2589CE8192748B28D2DD62AA97E78C7DED728931C69CAD1F83
CB768E1E738FB6996F49A6483FA25FFA4F3241FE193633A7FBAC0222791D9132
D3CD21AA8BE59F75AF4FE9E855D46057C73CB15B0929B1BCE3D248B4FAD4D039
74E19DEE2B9887E140801399E5D9D2687A4FE6FDEFE5BF32123662B6A487F14B
9D9A5B20898C25C34DD931F1B3323EA586CA1B50B9C689AC813A3838FBF0BD10
AE3F52378FE5CA9D10043E0DDF5406C0316645AA62B366569FE04F95E458E1D4
DD1D38766B6AFBCF3CFE9BBFF2EB908D91B24511AC525E15EA2EB389640C98DB
7016505A8DF7F307E7A7E8E64841163AB3E15D92C58349BEFFC4449F83280754
9F2403488CF2897D6757DDB50EC74C20E497DF8C5D90DF2EB6F0AC1527AD5DA4
7617A27763AE228559558798FF83A81BF4085AB6CA9944962E09541FBB7A0095
6D1ACA7D8C2355A394453D99349FC4F65130127A3BE67847808336771814F41C
3932EEE241576C9397E05345B2970824C7F1474677A412E2185C7314619180FE
81A7A5B53E6C49C1DC10CE4D1B7A2CE5F56F369AB2355524440AF33FE05CBDFE
D62624FB8C497B4F9E0CA92F06C6868964F7FA2E48176AB5869BC64A0C6E9B06
26C45A3FABBC14D169EEAB36866911279BC4AE282B4D575892594347780ED763
37619F86AF1FB6373D0CEE6B46717AC6B6E3EDAA054E5916B4684BA243F56FD0
07773CA0CFD5F930F3B3F5C994D3214A2D0851F039E95FCB1E54AF7301691C04
25A75BAF36903C96F1DF07C5ABAF2031162344AFB0255A91FF7A44F6B705CA7C
0B29FE1BCF088B4875981B3590EB6254FEE152B8F789FA9DC729609451258BDE
7360066362DB24465EFBADDE945CEABF0EA6EC704BF556C274C0C815503DB16E
32DFD00ACE836530F60D57253B67C93DBDECE93275A3DD6E8E44CEB8654AC79A
ACFCCBFAF40EDA07278DA544C77EEB19D151D290E50A0B9EF24A5ED767F4D533
BCCE084A7D159BDAFA098838737BF264CC73DA9A154016532EE90B7B3D7CAC53
C8293DA32993CCB41A92B979B9DCE91B5AE82CBF821D0CA2394715CBF564DA98
4FA597B04EDF4539D429AE594C7B889D256FF87219A9B80D4DD2F9F9347E39F0
37E0B3F85762A088176726F3333CC0516EE29A951A0332770F1EB78C7DC42F24
ACE8B379456632E7FD1AA490E97EF1BD458DF084F54818220BBAE9B11B05A685
D4C7E7EDFF51C6FE341E9B9B7DF58324AE6E3B639DDE323A6EEAFEA964B3F782
6E6964A1B3C9B2D82844A39AFF5F15E60E0F86581C921EC9198BC03CE04A0F0B
2113C7B19A19D7E46157DDB50EC74C20E497DF8C5D90DF2EB6F0AC1522A7835D
393308C37DCF78D696E409533BF93AA84D24E66719EEDE81E652B0347C8D04A0
59F61FB93A488160F65058FE9B3AB95CE02D75BD2FCC775E27EA978BF76D5B02
5A7B766FFA65AEA58C77DC4ED68C27DD8342B8B41BC7E2C78D6DE2F606721978
4B5B33CDCF28848A429DACE417CECEA2D839810D562BC8ABC3021191128220F5
E734EA2DE6F8CD4225EB94D4436925DBABC25C72216D96C9CB51264A9DF525C7
577F2777C4334EBEA72D599A27C0EED6598CEA99A13F659089458AC558B9F2EB
0504A2F8002B1B13E2A496759FF425467F458600B1A87AE31E65B7EFE7B1CB02
5613E530302E12BBEEF13F0EA2444B154323E8F7B43A98AE350BF276E1C1F837
B105D9B6BB9AD2454756638C8C23E1D19DBE673E1D7C76577E34ABE80ECF2F5D
6E13CBFC085918B9123793DECF156F4018399C3DF46C502CD19F672BCD4D19F6
D70059D309B72D0A48EC241A2CE1F3DBA7F211C30A4DC08B2473442AB0033628
5F6BF7604685676CFFF64C9F2630CABF2F83D137D226B905B6A47EEF5191B9AC
2F2B9589BB5E885F1F428E38F62E881F5CBA918F299A849F5ED006AA52A23114
F87C725ABE25F4729E57EE06E58446A7F3AA81126A78F40B6A381975E9A01692
A603FF9D104723BB02264885BF9DF7C77342796363A7B6B294CE26DBB9179DC6
4F2649842B599EE30047F31794AB9B449F059AE81AF15093EDB58EA45CEC2AFB
0B16C4540ED9969E2050F2B7EAE3FBE028D514C87A680A7A532F0E53AD0E8EA5
DD17590E8EDFA7C7C277BBF9E386D35F95636EC47102932576183606F932E533
7D2E447C602C3B28663DA9EBBAD493D051B6F151CCE21CDF95DC2A709409635B
9711CF60A04277EE7E0EB69D76392B84CF4115990D0B3FA0CA60A2E57AA31C13
71F8C279D4D209128D49A91E6EF714874953C224199FE70B61320E4513C0550F
41BFC2E5F4E9B5E7F367A32C0D1670ECD4F093223A64804E46E46F2BACB7F8AE
1F2AF3BC3643DF008FA6BC5CE7482C0F88494C1B514EAA2E470CFCF25D070AE2
A8E0DA1603969F8D10469A07844039C0FF5C49D1AD996A67AB0914D83D859C06
A631A916220AD14E1EAE70CE04774369D2044DA384CE7D0B193707C8E81744C4
554298A8FF1FBBCE9F4E5AA868C08720CB71E4A82E244D50B21E8DC2C3FCED58
5824BCB197550116C5BEA159FEF3D5FA6FD45EF8F497A755C379EA7F0B9848B6
0856430F4F92812F88D8275A376F0E26D9385DD6BC2814BC61E0606EADCE30FF
F66E5F798B36CB359B68951BF507DCC7B9DCAA16DE41C7270DCEF7D8E5441DF8
CD8BC1F2DB22A34743999D00A12F875843AD1BAC51663DDC28035DE9E4E09B42
DDEC0BB0B7D0305C78323040EE6FFD8E0B38B1C04757AFF485DFFB619F6D72F4
CECF77AEF515426928EA23B7DA0D408BC451D8D925361DA9BC2DDD1F6139A88F
BD2EC4C3FAACFDDC8DB45A14387C3E29D0173B3303AB7AE23BA78CF3769B6397
C8CB0B52EB155517FFFE630CFE58AC1791099EEEAA02D189A8F9863898BDCE6A
6EA04ACBCCB702719D386168CFF041EC2CE9A8434A7F3ADE382995A89581926C
9DA4FA99F8A99251FCBBE7043D98ABB3672F9F5CAEC8891E886FBC36C1A4B011
86F2E0A64FDB469583FC82790A54DE4B1EBA18F46B4743C7B67EA2A6C3B24ED7
0CC687995B467D7DCEE1D2F9E809A9B2E7CEB2E9158A48BBED491A787D3922C5
FABB15376E732C80935159C4C0C2A2F817C7033E99960014969BD78FD5873A78
58802ADBA74D21624D7F8658B8551A0931C76FB08669F4955EEEB8D76BFCE3F6
4A798F2493C7836B1C96677AD807732F0D7E60E61C766CE17CBE70B377AE8454
D242C1AE320DDD315061B192EB6E379737076AAE8AF242D9E0CAA0D81DB6CF42
A5E5DE6A05E51EC8CF922DBEF4BDF82BE1BA37E5F5DC73A479F7E25B0365BE9D
D6361DF6F18ADCD051288BA3E71CF87CAC524ECD9221A09907C96ADFD7508BEE
1DB370B662A55E5CE370D4F7E86B34BD9DD23C7B2BF2B8806528B6963C2E74F5
E8B478A4586B0FF2072B99F77B4359E7229E57336EA6E72727F61B8A14410F81
AFF39D3AE53D78139FED
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
%%BeginFont: HFBR17
%!PS-AdobeFont-1.0: HFBR17 0.6
%%Title: HFBR17
%%CreationDate: Fri Nov 22 09:14:05 2002
%%Creator: Harald Harders
%%DocumentSuppliedResources: font HFBR17
% Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
%%EndComments
FontDirectory/HFBR17 known{/HFBR17 findfont dup/UniqueID known{dup
/UniqueID get 4214379 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /HFBR17 def
/FontBBox [-94 -223 1033 751 ]readonly def
/UniqueID 4214379 def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (0.6) readonly def
/Notice (Part of the hfbright font family by Harald Harders, h.harders@tu-bs.de) readonly def
/FullName (Computer Modern Bright) readonly def
/FamilyName (Computer Modern Bright) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -100 def
/UnderlineThickness 50 def
end readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 22 /macron put
readonly def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AC06351EB3A0C388F7EDE3D9D355D9933DBEDDB5162DB2
E065C95E6D27BCABD3175EE1CE0E7E7C00571B5081E595D70C9CF1647EB0F53F
7298F407369B5B2256D99F3ACE73EA11EA8AEF444CC2B95AA8888CDDD54FAA38
349925414B53EBA844547DF4B6776B552C3A8A5E1051C9F8E9F2B66BB6A3061F
C0282C9E8CD03BA95B247F97135B16F1DAB3994CDDECEE9403F580D1969A0025
2F08C474B8150138DB8F140497B4A122FCFB523704946387C7914A41EEA71C35
648B00901FA34CDAB06B619384C4F526934C7C2A91AAC85CC609810F03D9496B
5BD6C447F90FDAA51F707015B02ECAE583744C6B0964C52972FF281B80F5F451
087788C8E189137109B84FAB4F6E04CE7022179B1E9CF6FE559C6D55BF47B916
25B27368C4551690821829E126E57EC510BB502E5D3D25F50CDC819787F40120
C3D711B1BD0209A7ABE581DFDCDFD04ABF3F0DA4F415ECD1EC832117A68D5D6B
3B3B0818DAEE02D3ADEC95240A5502E4954CEBBB8E661393B930B84A4245D041
6C6753290997847BFFFBCF81533E6C8B288D3461D538B14967C0F52D2FB2614A
2888141874D4CA026CC702ADF32D6B1AB373BE26E78C1980601C038F348E0986
F3F4100046BD27AE131BF12CD2D796EF9737DCC250869941E5BF61CC4E39C8D8
C7B4492BBAA245A69AB37F22ACEDF09CEBAE8DEC16B1001A4FACC855FAF32182
7A1F05C43CAC6F7EA517D9C60616AECE2BD516C03E0F58061A6238F27BED11C8
72616435449EFCBD1ED05BA4029078C005AE5200890DCE632709729B2FEB015B
9344BC296D740FF889CBB5D7FDBDA6DA578660E98E8446E6C56147D917CC6CB0
7A4E36951BE65362AD44678B339B70B405F0B3471A26A1125500A3FFCDC35F4D
3C6C27A5E56E8ADD6E7F82E269B8DF5AC490A9CDD2F9FDE51054CE4628A1E920
D5520CEACB67AC9A4CA3EC448A6EB0FD22136D84749F2C95F3B60B2051E2A962
5684D860C18449E23F63449A10FDCBE4404FC1E1FBE6B4535E05FD3624FF13AA
842A8BF341C9C175AB010CF3F19ED92296988F007661A366BA039100AC61BEA2
CF469C466CAA8D6DDEB5DEDC6B65CE7E2E3A2773D105E04AC8D82CE73DAD64AC
095446093002BFCE70619136121D6C48A9B1D12BE160061ED533E438095CB89F
68C9B792C7C67035A92CE145E3E9E5799F785B7BA091088A3498B0E1130F7104
7283C2E4F25E261C9F7843A3D01D4112F3060255C86F40E83FDF8B484BDD3433
5B4F9566E6946D364C6432F130D6A1C170C88801FD2F3569C8CB6AC9631F3080
356808CAB09B3E1808130B28ABEB3D6D65B2A1F61B11D8AC23553B2441E107F7
C2FFF7F0D500812A62720DCA1E6AA9A4F3E7CF50FD35317B850E71A8B57228D3
CE502BF49DA49403BEE7BE296D21BF02697C0A8231D28E8D575F6FFDB4009F6B
C1809757AE518EB634A08934BD216B2CC68F8665723AB892B0998AF9F9E27381
AC0BF6E95D173F88AB770E872B10390480218546925AE0197B8EAA71EE7496F2
B029972C73FE2F09C0D47014F04BC8847046D87BE850F05FB53DBD32E2A48F7E
679CEFECAB1281AA88A82A9D264D6A55043F44D1AF2F788D120D41C1D2E6CA8F
C4217BD0C947E3357519558D2DB6E10F552D8251DBB7F9ADBF5E7ED15F01465B
3AF50356765277B629FA25BD8031888D9602BEC7DE105CE5181F2351811FE012
0BEBE1AD8A36058C2E86C4EFF720819F67E929F1B96E09DFBA8D9BADF023FBC0
31691B4DA9809F36BB7012622DB3C19A06A448F1A2A7B59FF3D0F31E4A68C9D8
D3AE952BA1590903BCCDC2090E15D5FC15748BC6BFC3708C798727EAFE8BFF01
5F8A2FF4BE1EC70321D7214FBBFC4B87AF04EB5519FDD12973D0BE06E4D9B72B
E518F358841D15F962EA2DD07FED784FB9D24A2F35D3859304677B36A5091D14
90CAFFEF699FC3B77AB798355F8E986A16FC63F315D741CD04EA3DB40C01F48A
8447083E979D7BD1417721BD45B540699FC9C214DF55DF577EF7A9517F7F6FC7
4BA773010F2DE5E74EF257309F7AD43D7C97CE9C096849D9669BB3207188AA1A
9D3EE592E4406523F2998487F9CE5876D4B955D7FA52A0A7F28A785EB427FF1C
56D32224623D322A81E8A5E355521FFF35531F5B3D94CE044A5586901B421C4C
3629142C8D45877865215298895A1E253F959ADBCC9F274220F9DEEB46B59116
16561A612960F4D27AB6AF9E76EEA91789DD205EEDF187532CE89D3F1FC13C77
D7A3C568E43BCA7838F0114A75CD97852D553EAC112F5B10A7C4E36755775CFE
3FA6B73C6D8DFEC8B862CCBA1482708B0A1300DFF338D18403B0D32B490CCA0F
2AB02642665961BE89B3388CAAE13B9F38F698595E1938DA9804980CCB41AB46
D767C5FD8EEEB8E7D234BCBAE74B248394E5DC0215BF40D6E4849F0CE7F979BD
20EE59E64E6BA6ED387C94D690BA572AA28C49C61E8C48B87CC637D0DFA3ECA2
7DDFEDE77491D45FB0F60CE186634FC24745A46C209CA0DD1C752FD256E593DA
4D0D70338869F56B2EFB1E02FC53C8FF43BC614C10A44BFFD1164750A7E95825
D50C75E8172C8EFB1E5A408243DA9B276172D2C46B0D41B616D8BE28D215A6ED
AFA6A3425430DE28BD69E05949E4CEBE6F6A944A130DE968827E8917F720363A
88A9876A070123EAA39350DD393948217433D809D2C7C4FEDBE462F0165D2938
F24D89B9EA9D7AD4E80B6BFC10D56CAD742E3A4E2124BB7807A03A50CAA1C874
E94919099CC05BA581120D5374A25A9C8EF3C05B98AEF772FD5920A930FEF210
6BF2C25AD81ABCA60305FF826246297DF366FD4A9E6BCB371E128C50D57B5B60
CA3A75336EF244ECBC30830422A9F2B546C41C385BCA1EB2F5849C411A6AC641
DA24E8E3278B1C8F468158673D609932BAD47DE672B456136DDFB48305FA47E7
10C9346A964084D6B5FF04E8D05B1AD74A52CA3A40E74393CE2F3307C26214BE
830A143D9BDFC988320A15C8F49EFA91EB025044824BC882B592BAFA186469D6
3638C9C2E7FAC818DF24038C7DF8773810363633F9564C1E2C9D51C70A39679F
49951EC65267A32F95142810C1B0EC2B794669C280D5789166BF3F9916872D29
3F50E2102B435493B0B726C9BFFB996453DE513E1EDA1F8BB3442BACD8DCBAE4
3D09BB0D5D806E1FEEA118EACE8D6F71C290FA0D800FE75C822B126146943463
ECD07D8D522AF900D44EEA6FCBB66C5745F4B499C7306AA8A7FE2D05E5C0021F
A7F9B09CD58109D6FD9D9DE483B2FDF0B8FE744F66F92379E0860C35CCFD96EC
9DCC10B4CD58EC6F7586149685B242289CB6CED7CA847BAE4A4A94C9A06F1218
46554216ECB8AF2F40BBA94069B56976E697532F38850901F6CB4293B1F12A30
A9773B700855C6A2051C3F274AECDDDC62994D5D9765F70424F232E9C3EEF449
FEF50A059A37308680AFA3269DBEF281B1FAF2D0DFB67611272A222C9AB86044
87C30309DE030E90CE7D1EEFE21ED849C23D34F456F8195ED8ED363BC169BACE
149664C7EB6F76F7CB6FFCFF621B241CB320302279006DC8193093B5B0577BBB
622629A5C2C8B3BF5553E46A17C821056C9E01805B8EAF79864C12A3C32FA647
19D02290C8E54C15CB108FD05C192269E82120F25D0FA35461BACD87FF11FE66
5652131E9BACDC3BEDAE45AEA5AB50964ECE536550806FBCBD6EF924997EB6FA
92F450F153122862429AC7FE6D6C758C8E23BB48167270DED69536B9C4BC601E
6D32180EB06F50CD9DB7E703C99A3B7C21E22E7BBFEA40DB5D3B27F2E3677E25
7AE23ED678780824D86FBDE64637AB2D22F8BB5432F04531BCF1F720D5BB2F4A
AB7C0583FED810F871A1433C41234AEB79C3A7D8DFC370DB9A001370CAED3B3D
6FB0D6BFE8327B9FA964E88824F0948EC8B8B55B2DCBB7F66F873548FBEDD20A
2E4B9380DAFA1769E0F7BB4CA1DA466A2BB32A26966C74476CBDF6062A987771
96FA7D77F55815C8C02E3B18F74DED56A93560E70D0EFFDDE6B8F0561529EA30
83ACB01FBDA6937697899AF813F87FAEB3C2303602FF99ECB54820325046F076
D550F8B12FD6EF41EB595FF2D9D21F402B257A7EDF489685C0AA021AA8F9DDBE
E2F3D4B1C79EC1B8991A08302B50DAB1A126DAB17B1F5898AFF3D0F482C5B286
510301A965A811ADCD0629676BF2153F2BE06BBD89CFD73980B5DCB6DF0B0C80
DE2A649AF64CC186AD241201F7C249CBAA7CC5CE84C5DF32F27B0F23E33DEA58
9CAEDB581883BA6BB13C5763B0E72D099960E7B919A1D1E5B0A19FFF54D28050
5BC35CB1E48BADE53A0606A47FAF4F40B697BC83191F20AD2C1825BFD6456EEB
D1D8FFDE3D6D99ACB1509DB64B4755D4650B967F299FBC083A7216A9D7C8065A
48AAFDC4DACA5ACC0164667F12E4001CFEF502BCEE4BE73BFB98CC186D226BA6
A2A0F2100B2EBA9EAB858CE982903E1432881FBA6BF3A654B3AA235E92AE8D46
2F66E4EC48361ADED61E2B4BA8BE5A60CC92056F4724922B4D93EE1ECAD8B3EF
EA466D5CA0CFA03A28A7B8A20B53B1980357E446B2E1A2FA9019673FE9A00CDA
03A659D958E523269EFFDAE699CEC7DB3BA7F306F30101C36838220F20586162
3287FE3E914E8AE5FC07C3BE2AA29849E07832F3EC791402FAA03E723E92ED92
F504EA314188ED9E9B2299ED2868667533F44ACE999AAD09EC7FEE1BE0C66657
9D7CB12B10437DF77C0EBC4A8DA32265B1DD32B979BEE440A753F00BAB778ED7
0527E024BB93621522BE34C5E58B905586EA0C6A13AA0292913337847D46A30E
4B306844C7ADB682C3D2B88F78A88B9A7560BC32A865288FE5E8E881E9B4F634
6A6F106B2CC6DCD5AB54BECCEF2C46ADC25D54E92FA1C8D94F8D3BBB87C0040D
FFEA972ABBF5D42B9E31756579015508C29E2C44927478FE4A374EA3C9F2578B
A5117873861A0308ED0B74F14D65AFDE99B9252A190F95AED5FA9523A6445BF6
7BBC902B0B2A84DB96138FE7EE2F986A7B8CE9CD62E028020CE3C43EAE793087
8853FE37499320EFCF0AF65E2F62A6C9C91A97D9D97ACFD939502C400CE91891
D618FFE0ADCC54A5B1B947963E98335B65758855C061EA39BE0B43419985C499
B4656B6A83DE8572F6C63DAA93988945C0F3DE978A1E97DFF6685E24932C8B3A
D14BB1617542CCB6E265E270FEA2DB605D13F0CDFA37621D85A8DE4ED231DB0C
307CEF4391C4A98189CBFBD4F89DA1264D4CEE04B5C66D39F7907002B1BD853D
A64E27BDEBB2BFB259CFE36C42498D2B107B5AF139F8B429FDD5637AAA660AF8
869840DA9CDEBD70063054DF5516774AAE0AC6D572138F1322B64AE8CA2FEA50
11719B137D016AF46B4F2EA22733A097C5A305018F161F4C72696272196D624C
66DA1AA7C093124512D331AE1A48A758FEDC5EA066F6761C9336B808BCC8A27B
7CC1F8BDADDDA26E751AE27AB03A7E3FE21296C0D1D5630335E2A63135D32E82
E5692DFF48D51C70503900DECDF1516F95ECC1425692C2AC35B41B650A3337D4
4C90A9B06E8A64FD99C37EB496BFF127BB9388D11E687515911178266E49D48D
7A1A2ADB104DAE5EDCF7EE87390A7CE57D8AE66173A327D681CADA1F315194AB
D6ADBFF7156F95D2F3458AB8F4E07FF33C44F3C52FCAA99B5A1D11B72AE0780B
C0AA4B162C599C270D429C67AFCC4E78B33E973793C2AB02CBEA99243D10807E
D98A7D082A15A6021EE42BD8E77DC4249682B14B04F02229AB7A0E09A73D9E77
41B68234656B3226202C0F94FD916FDE12756CCD6886F5D61BD2580BE96EBCAC
F0CECA992773288CC329C1F1E71DED385A50EB9E8ADCD0DE83978657A379834A
7C2FF9FC63B86A07D32FC592466D61B463A51231567FC512C7A765484C6C2C92
C065BB918986A79F148C01C938034517F81E313CF4A8EBA40FC9021EE3A66FB4
034FC5A57D6BB6CFD514927B8DD9D03311A469FBEB7342B01BE83F223FDFF7B8
532042FB02B9C9EA74C7FD375D4E0BD0285DB7996C7C9B707D2BBD373D7A5206
341FDB08B822D5F5031EB4E5E17FBE63367B68B8ACBE3570C1D8CE854738FE8F
5759C908743188DC2F62158DBC3C10A0B8C017DD155FFB73077EE7C9E18A7DCC
29B3F53796638CB6AFB37D781D896FE2A3F9B9B33DAED767FC5861119DA26D6B
B2DB3E8700E288BFE9AE13D382795C27BFDB380AD6E6EC83AC6F78DC6858B31B
0F92E87BA1B8CDAA99DDED1CA41823DF8E35FF55EB4C5F69BA2B3BA6403D5579
6B8077406DE10470CB0E74249D56EE9DE5E945AACFACF4D0241141651E57ACF1
ED797DC16583BC5FA9A4B6F10A3DACE47CD20AE31A843C4E0355FC1FD993B340
AA1B2C917DFFFB977724AFF3B1B8884D88E7E9B42872C3206B2F3E5B37959300
13658335EC608B9EA05AD68D4E350BF9048CB5D8AF8E68D7DD038937B616F70F
63C97C372C34B87B3E010DBCD3DB4FF957C31793731F750A12F448F84BA54B79
76F6F1CF71DAE96F58FCC4EB9FB80A786D1842AFA83811AAC5475F885D1BAA68
167255D1A4471FFC2F4134C1D8009FFE8880902DB8A65D4C99A2420924FD55E0
8F3FC11D34A26E6873B491E6B18AADC11CF5ECE04A2A87FF454E6B8552887709
21600104E936C70DEF61442C997CF0C1057D495CD2E6890DAA9E422788DB3D99
BE5F0618A2D30B7AA15F768FD4A5110FF764E6AF2221878A77DB2112FF6C2860
8A711337682A19C178709C7443679225F69925610586EF914EB7C5D101C0FD1D
663D236EDED894B0B32E998FCEAFB163672E0C669DCD07F7FEFE9EFBB3C85507
5D5C89041F9E092D090669046F317B46EA64A8AB39B26DE70B2ED2C8D63AAE03
009E39867DF9CDBFCFEF977781E859A426B0A1D568C2BE097DA233C7C41AB0C2
4141BB2E01BB3E0730ABFCB0D6C50B09FB5AC55E47E99F8237E07C1CBF535676
A86300FC2F16205A0073AF60769399B2906430C8F60F7A5B95A7A06A404D397F
1BCCD9890BF4BD28BB0E00A36B9927A1B3CE937C2D444B89840FCF3C07ACA32A
7F2B574B0542AE4BAA9D79D0458738C56A80BDDBDB895339346A419F2E560F2C
28E3055F1F1585D02555A6DBEAC9DD11C5C77066D99F25E6934397154502A84E
43D90739AF819EE3B6241A13575879EB5BD3DEEF43785067ECE5016BF45C4CDE
BFE4806FEA0F4CB7F4005D3623835A90979576A710167746CC66340D7577F1AC
A2FEDA4BFBFA92699F977EE459041132911D1B85553BF5CA911A52B6C639F393
7C2C0689D7C08F9BA79A2F159CFEB2F65AA299E076295312A968B683D01AB692
33032D4B9A34EE00A7F91CF965ABA31F2A458B2FD6F0AE3B985A97EEDA78424E
6AD6B3ECFBD825A5369AAB6EBA67045CA1E377D243B29C2480EE80B36DED49B8
A2952586CC64B15CFF82D44F6350E10D345597BFECFA58FF527CA463010C00C3
CB719071EB99D5503675A378592A438932487AA91893DBCF75D4B3B2D7B8FD81
3AFCCE066BF28F73F5ECABA0E658E07BFD9A5A80BDF19A682166531A6CE74D9B
7129267C05F4AEB6B4F3FB66EAA788422952D1005DAAAB84B4F1C69857FF9D69
4B06EF3DD699119A11B6B3D05E3D6311C4D1DE94B142D255D9CF6EF112F4902A
F4DCF058DE698512493CFB72DA0F5B5B70AE4C0DD215C4961B4BF55B69A1A3FD
861565CA746D4F1661DCA496064B802D074CE4A00DEBB6B26D85FFA25FBAE4BF
76BA6DB828E48ECA9018B12EA9801A93DBAE44806D011AB8ECFCF657196751CA
0EF067C6A5F90F2E909EADEC95240A1E64134B3C45AB29A9DD7B3225E0B4A3BF
6D8C1C822C4DA3FB1A29EC490218DDB41CD0AF1D9291210698EF9475CBCB8859
3FD61E5A0DC9B97042D2CF75D663079A59111A72159EA07AD3F2979C3704AFEB
4369100FDCFBA208DEC7F3C96A180D05BFFE42F8C73E901309F77688C2E1C4E8
A4D489E7A4B1818B65D8EA1023E9283847B86663FAD6A82C3048994C4FDABDB3
5284A08162C1B4B2391C0A1A36A8B78CE504279E1A9C88
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 37293595 22376156 1000 600 600 (ttbb_FSR.dvi)
@start /Fa 212[93 43[{}1 119.552 /HFBR10 rf /Fb 255[93{}1
119.552 /HFBRSY10 rf /Fc 139[65 17[89 10[151 87[{}3 172.188
/HFBRMI10 rf /Fd 233[88 22[{}1 172.188 /HFBR17 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop  0 TeXcolorgray  Black 0 0 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 0
0 a 0 0 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 0 0 a 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
1 TeXcolorgray 1 TeXcolorgray 1 TeXcolorgray 53 1631
3418 1628 v 1 TeXcolorgray 0 TeXcolorgray -1604 1606
a @beginspecial @setspecial
Black 208 0 add 194 0 add 320 0 add 194 0 add 7.5 9 0 2.0 1.0 doublegluon
 
@endspecial @beginspecial
@setspecial
Black 208 0 add 66 0 add 320 0 add 66 0 add 7.5 9 0 2.0 1.0 doublegluon
 
@endspecial @beginspecial @setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 320 0 add 194
0 add 432 0 add 194 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial
@beginspecial @setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 320 0 add 66
0 add 320 0 add 194 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial @beginspecial
@setspecial
Black 528 0 add 18 0 add 432 0 add 66 0 add 7.5 5 0 2.0 1.0 doublephoton
 
@endspecial @beginspecial @setspecial
Black 528 0 add 242 0 add 432 0 add 194 0 add 7.5 5 0 2.0 1.0 doublephoton
 
@endspecial
@beginspecial @setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 432 0 add 194
0 add 528 0 add 146 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial @beginspecial
@setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 432 0 add 66
0 add 320 0 add 66 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial @beginspecial @setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 528 0 add 114
0 add 432 0 add 66 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial
@beginspecial @setspecial
Black 464 0 add 82 0 add 528 0 add 66 0 add 7.5 5 0 2.0 1.0 doublegluon
 
@endspecial @beginspecial
@setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 576 0 add 82
0 add 528 0 add 66 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial @beginspecial @setspecial
Black   {  1 2 5 0.2  arrowVTriangle  } 0.5   false 0 0 528 0 add 66
0 add 576 0 add 50 0 add 2.0  1.0  dasharrowdoubleline
 
@endspecial
Black 1395 1250 a Fd(\026)1384 1274 y Fc(t)p 0 TeXcolorgray
Black 1384 -96 a(t)p 0 TeXcolorgray Black 2882 654 a
Fd(\026)2879 692 y Fc(b)p 0 TeXcolorgray Black 2879 402
a(b)p 0 TeXcolorgray Black 2879 1606 a(W)3055 1543 y
Fb(\000)p 0 TeXcolorgray Black 2879 -345 a Fc(W)3055
-408 y Fa(+)p 0 TeXcolorgray Black 3255 903 a Fd(\026)3252
941 y Fc(b)p 0 TeXcolorgray Black 3252 1232 a(b)p 0 TeXcolorgray
1 TeXcolorgray 1 TeXcolorgray 50 3 3425 4 v 50 1632 4
1631 v 3471 1632 V 50 1634 3425 4 v 0 TeXcolorgray 0
TeXcolorgray 0 TeXcolorgray eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
